package migration

import (
	"fmt"
	"strings"
)

type createTableSQL struct {
	Statements []string
}

func generateCreateTableSQL(mi modelInfo) createTableSQL {
	cols := make([]string, 0, len(mi.Fields))
	idxs := []string{}
	var pk string
	for _, f := range mi.Fields {
		col := fmt.Sprintf("%s %s", quoteIdent(f.DBName), normalizeType(f))
		if f.NotNull {
			col += " NOT NULL"
		}
		if f.Default != "" {
			col += " DEFAULT " + f.Default
		}
		if f.AutoInc {
			col += " GENERATED BY DEFAULT AS IDENTITY"
		}
		cols = append(cols, col)
		if f.PrimaryKey {
			pk = f.DBName
		}
		if f.Unique {
			idxs = append(idxs, fmt.Sprintf("CREATE UNIQUE INDEX IF NOT EXISTS %s ON %s(%s)",
				quoteIdent(fmt.Sprintf("idx_%s_%s", mi.TableName, f.DBName)), quoteIdent(mi.TableName), quoteIdent(f.DBName)))
		}
		if f.Index && !f.Unique {
			idxs = append(idxs, fmt.Sprintf("CREATE INDEX IF NOT EXISTS %s ON %s(%s)",
				quoteIdent(fmt.Sprintf("idx_%s_%s", mi.TableName, f.DBName)), quoteIdent(mi.TableName), quoteIdent(f.DBName)))
		}
		// foreign key constraints
		if f.FKTable != "" && f.FKColumn != "" {
			idxs = append(idxs, fmt.Sprintf("ALTER TABLE %s ADD CONSTRAINT IF NOT EXISTS %s FOREIGN KEY (%s) REFERENCES %s(%s)",
				quoteIdent(mi.TableName), quoteIdent(fmt.Sprintf("fk_%s_%s", mi.TableName, f.DBName)), quoteIdent(f.DBName), quoteIdent(f.FKTable), quoteIdent(f.FKColumn)))
		}
	}
	if pk != "" {
		cols = append(cols, fmt.Sprintf("PRIMARY KEY (%s)", quoteIdent(pk)))
	}
	sb := strings.Builder{}
	sb.WriteString("CREATE TABLE IF NOT EXISTS ")
	sb.WriteString(quoteIdent(mi.TableName))
	sb.WriteString(" (")
	sb.WriteString(strings.Join(cols, ", "))
	sb.WriteString(")")
	stmts := []string{sb.String()}
	stmts = append(stmts, idxs...)
	return createTableSQL{Statements: stmts}
}

func normalizeType(f fieldTag) string {
	// allow explicit override like varchar(50)
	t := strings.ToLower(f.DBType)
	switch {
	case strings.HasPrefix(t, "varchar"):
		return f.DBType
	case t == "text":
		return "TEXT"
	case t == "timestamptz":
		return "TIMESTAMPTZ"
	case t == "bigint":
		return "BIGINT"
	case t == "integer":
		return "INTEGER"
	case t == "boolean":
		return "BOOLEAN"
	case t == "double precision":
		return "DOUBLE PRECISION"
	case t == "real":
		return "REAL"
	default:
		// fallback
		return f.DBType
	}
}
