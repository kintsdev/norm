package migration

import (
	"fmt"
	"strings"
)

type createTableSQL struct {
	Statements []string
}

func generateCreateTableSQL(mi modelInfo) createTableSQL {
	cols := make([]string, 0, len(mi.Fields))
	idxs := []string{}
	var pk string
	// composite groups
	pkGroups := map[string][]string{}
	uniqueGroups := map[string][]string{}
	uniqueNames := map[string]string{}
	comments := []string{}
	for _, f := range mi.Fields {
		col := fmt.Sprintf("%s %s", quoteIdent(f.DBName), normalizeType(f))
		if f.Collate != "" {
			col += " COLLATE " + f.Collate
		}
		if f.NotNull {
			col += " NOT NULL"
		}
		if f.Default != "" {
			col += " DEFAULT " + f.Default
		}
		if f.AutoInc {
			col += " GENERATED BY DEFAULT AS IDENTITY"
		}
		cols = append(cols, col)
		if f.Comment != "" {
			// escape single quotes
			c := strings.ReplaceAll(f.Comment, "'", "''")
			comments = append(comments, fmt.Sprintf("COMMENT ON COLUMN %s.%s IS '%s'", quoteIdent(mi.TableName), quoteIdent(f.DBName), c))
		}
		if f.PrimaryKey {
			if f.PKGroup != "" {
				pkGroups[f.PKGroup] = append(pkGroups[f.PKGroup], quoteIdent(f.DBName))
			} else {
				pk = f.DBName
			}
		}
		if f.Unique {
			if f.UniqueGroup != "" {
				uniqueGroups[f.UniqueGroup] = append(uniqueGroups[f.UniqueGroup], quoteIdent(f.DBName))
				if f.UniqueName != "" {
					uniqueNames[f.UniqueGroup] = f.UniqueName
				}
			} else {
				name := fmt.Sprintf("idx_%s_%s", mi.TableName, f.DBName)
				if f.IndexName != "" {
					name = f.IndexName
				}
				stmt := fmt.Sprintf("CREATE UNIQUE INDEX IF NOT EXISTS %s ON %s", quoteIdent(name), quoteIdent(mi.TableName))
				if f.IndexMethod != "" {
					stmt += fmt.Sprintf(" USING %s", f.IndexMethod)
				}
				stmt += fmt.Sprintf("(%s)", quoteIdent(f.DBName))
				if f.IndexWhere != "" {
					stmt += fmt.Sprintf(" WHERE %s", f.IndexWhere)
				}
				idxs = append(idxs, stmt)
			}
		}
		if f.Index && !f.Unique {
			name := fmt.Sprintf("idx_%s_%s", mi.TableName, f.DBName)
			if f.IndexName != "" {
				name = f.IndexName
			}
			stmt := fmt.Sprintf("CREATE INDEX IF NOT EXISTS %s ON %s", quoteIdent(name), quoteIdent(mi.TableName))
			if f.IndexMethod != "" {
				stmt += fmt.Sprintf(" USING %s", f.IndexMethod)
			}
			stmt += fmt.Sprintf("(%s)", quoteIdent(f.DBName))
			if f.IndexWhere != "" {
				stmt += fmt.Sprintf(" WHERE %s", f.IndexWhere)
			}
			idxs = append(idxs, stmt)
		}
		// foreign key constraints
		if f.FKTable != "" && f.FKColumn != "" {
			cname := fmt.Sprintf("fk_%s_%s", mi.TableName, f.DBName)
			if f.FKName != "" {
				cname = f.FKName
			}
			// Note: PostgreSQL does not support IF NOT EXISTS for ADD CONSTRAINT; we'll de-dup in planner
			stmt := fmt.Sprintf("ALTER TABLE %s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s(%s)",
				quoteIdent(mi.TableName), quoteIdent(cname), quoteIdent(f.DBName), quoteIdent(f.FKTable), quoteIdent(f.FKColumn))
			if f.FKOnDelete != "" {
				stmt += fmt.Sprintf(" ON DELETE %s", strings.ToUpper(f.FKOnDelete))
			}
			if f.FKOnUpdate != "" {
				stmt += fmt.Sprintf(" ON UPDATE %s", strings.ToUpper(f.FKOnUpdate))
			}
			if f.FKDeferrable {
				stmt += " DEFERRABLE"
				if f.FKInitiallyDeferred {
					stmt += " INITIALLY DEFERRED"
				}
			}
			idxs = append(idxs, stmt)
		}
	}
	if pk != "" {
		cols = append(cols, fmt.Sprintf("PRIMARY KEY (%s)", quoteIdent(pk)))
	}
	// composite PK groups
	for grp, colsIn := range pkGroups {
		_ = grp
		if len(colsIn) > 0 {
			cols = append(cols, fmt.Sprintf("PRIMARY KEY (%s)", strings.Join(colsIn, ", ")))
		}
	}
	// composite unique groups
	for grp, colsIn := range uniqueGroups {
		name := fmt.Sprintf("idx_%s_%s", mi.TableName, grp)
		if n, ok := uniqueNames[grp]; ok && n != "" {
			name = n
		}
		idxs = append(idxs, fmt.Sprintf("CREATE UNIQUE INDEX IF NOT EXISTS %s ON %s(%s)", quoteIdent(name), quoteIdent(mi.TableName), strings.Join(colsIn, ", ")))
	}
	sb := strings.Builder{}
	sb.WriteString("CREATE TABLE IF NOT EXISTS ")
	sb.WriteString(quoteIdent(mi.TableName))
	sb.WriteString(" (")
	sb.WriteString(strings.Join(cols, ", "))
	sb.WriteString(")")
	stmts := []string{sb.String()}
	stmts = append(stmts, idxs...)
	stmts = append(stmts, comments...)
	return createTableSQL{Statements: stmts}
}

func normalizeType(f fieldTag) string {
	// allow explicit override like varchar(50)
	t := strings.ToLower(f.DBType)
	switch {
	case strings.HasPrefix(t, "varchar"):
		return f.DBType
	case t == "text":
		return "TEXT"
	case t == "timestamptz":
		return "TIMESTAMPTZ"
	case strings.HasPrefix(t, "numeric") || strings.HasPrefix(t, "decimal"):
		return f.DBType
	case t == "bigint":
		return "BIGINT"
	case t == "integer":
		return "INTEGER"
	case t == "boolean":
		return "BOOLEAN"
	case t == "double precision":
		return "DOUBLE PRECISION"
	case t == "real":
		return "REAL"
	default:
		// fallback
		return f.DBType
	}
}
